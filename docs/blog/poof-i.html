<body>

  <div>
    <h5>Nov 9, 2025</h5>
    <h1>Introduction to poof</h1>

    <!-- <div class=part-link-container> -->
    <!--   <div class=part-link> -->
    <!--     <a href='/vim/blog/gui-i'> -->
    <!--       <h4 class='part-link-0'> -->
    <!--         Part I -->
    <!--       </h4> -->
    <!--       <h4 class='part-link-1'> -->
    <!--         Displaying Engine Data -->
    <!--       </h4> -->
    <!--     </a> -->
    <!--   </div> -->
    <!-- </div> -->

  </div>

  <div>
    <h3>Introduction</h3>
    <p>
      <a href="https://github.com/scallyw4g/poof">poof</a> is a metaprogramming language designed to assist with certain tasks
      in <a href="https://github.com/scallyw4g/bonsai">Bonsai</a> that fall
      somewhere between 'intolerably painful' and 'practically impossible' by
      using traditional C++ template metaprogramming.  In fact, as poof
      matures, nearly all of C++ now resides in the 'intolerably painful'
      category.
    </p>

    <p>
      Poof operations are generally based on one of two revolutionary
      constructs; looping, or branching.  For some reason, the C++ standards
      comittee decided to make these operations .. uncomfortable .. in their
      metaprogramming language, so I wrote a better one.
    </p>

    <p>
      The poof compiler runs as a two stage process:
    </p>

    <h4>Stage 1</h4>
    <p>
      poof runs a bespoke lex/parse stage on the program source code.
      During this first stage, it builds internal representations of the
      datatypes found in the program it's parsing.
    </p>

    <h4>Stage 2</h4>
    <p>
      poof scans for instances of the `poof` macro keyword, which contains
      the metaprogramming code.  It interprets this code and emits the result
      to a new file which is #included directly following the poof macro.
    </p>


    <h3>A Contrived Example</h3>
    <p>
      Using poof typically follows a pattern similar to the following:
    </p>

    <h4>Define a datatype in your source code</h4>
    <code>
    // this can be any valid C struct, enum or union.  A subset of C++ is supported.
    //
    struct example_struct
    {
      int SomeNumber;
      unsigned int SomeOtherNumber;
      float FloatValue;
    };
    </code>

    <h4>Define a poof function</h4>
    <code>
    // Do this once globally for your program.  This is how we embed poof code
    // directly into our source files.
    //
    #define poof(...)

    // This function iterates over the members of the input type, and emits a
    // comment with the type and name of each of the members
    //
    poof(
      func babys_first_poof_function(type)
      {
        //
        // (type.name) contains the following members :

        type.map(member)
        {
          // member.type member.name
        }
      }
    )
    </code>

    <h4>And call it!</h4>
    <code>
      poof( babys_first_poof_function(example_struct) )
    </code>

    <p>
      At this point, poof rewrites your source file with an #include that points
      to the generated output, similar to the following:
    </p>

    <code>
      poof( babys_first_poof_function(example_struct) )
      #include "generated/babys_first_poof_function_example_struct.h"
    </code>

    <p>
      And the output in the file 'generated/babys_first_poof_function_example_struct.h':
    </p>

    <code>
    // callsite
    // src/main.cpp:10:0

    // def (babys_first_poof_function)
    // main.cpp:8:0

    //
    // (example_struct) contains the following members :

    // int SomeNumber
    // unsigned int SomeOtherNumber
    // float FloatValue
    </code>



    <p>
      There are a few things to notice about the above output.
    </p>

    <h4>Header</h4>
    <p>
      The comments on lines 1-5 are generated by poof for most files it generates.
      They point to the source code location where the poof function was
      called, as well as the location where the poof function was defined.  This
      header is configurable if you wish to emit, for example, documentation,
      or source code in another language.
    </p>

    <h4>Comments are ordinary tokens</h4>
    <p>
      The output of babys_first_poof_function is strictly comments.  poof does not
      generally differentiate between comments, strings, and source tokens,
      which means that you can produce both comments and strings with all the
      same poof-enabled goodness you use to generate real code.
    </p>

    <h4>Include</h4>
    <p>
      poof generates an #include with a default name, which can be modified if
      you prefer a different name or output location for any reason.  Before
      writing output to the default filename it generates, poof checks to see
      if there is already an include directly following the poof block, and
      blindly uses it if there is one.
    </p>

    <h3>A Real Example</h3>
    <p>
      Emitting comments is a cute party trick, but let's make something that's
      acutally useful.
    </p>

    <h4>Generic DebugPrint</h4>
    <p>
      We could use what we've learned to far to write a generic DebugPrint
      function that pretty-prints the members of an arbitrary struct at
      runtime.  This is a good example where poof excels and C++ fails
      miserably; doing this with templates is a <i>fucking nightmare</i>.
    </p>

    <code>

    // First, define some helper functions for the primitive types we're using

    void DebugPrint( const char *Value )   { printf("%s",  Value); }
    void DebugPrint( unsigned int *Value ) { printf("%u", *Value); }
    void DebugPrint( int *Value )          { printf("%d", *Value); }
    void DebugPrint( float *Value )        { printf("%f", *Value); }



    poof(
      func debug_print(type)
      {
        /// This is the C++ function definition
        ///
        /// NOTE: Comments like these with three slashes are not included in the output
        ///
        void DebugPrint( type.name *Value )
        {
          /// Start by printing the type name, an open brace, and a newline
          DebugPrint("type.name {\n");

          /// Iterate over the members of the type
          type.map(member)
          {
            /// Print the name of the containing type, and the member name
            DebugPrint( "type.name::member.name =");
            /// Print the value of the member, followed by a newline
            DebugPrint( Value->member.name ); DebugPrint( "\n" );
          }
          DebugPrint( "\n}\n" );
        }
      }
    )

    // And call the poof function on our example datatype!
    poof(debug_print(example_struct))
    #include "generated/debug_print_example_struct.h"
    </code>

    <p>
      Which produces the code :
    </p>

    <code>
    // Header omitted for brevity

    void DebugPrint( example_struct *Value )
    {
      DebugPrint("example_struct {\n");

        DebugPrint( "example_struct::SomeNumber =");
        DebugPrint( Value->SomeNumber ); DebugPrint( "\n" );

        DebugPrint( "example_struct::SomeOtherNumber =");
        DebugPrint( Value->SomeOtherNumber ); DebugPrint( "\n" );

        DebugPrint( "example_struct::FloatValue =");
        DebugPrint( Value->FloatValue ); DebugPrint( "\n" );

      DebugPrint( "}\n" );
    }
    </code>

    <p>
      And putting it all together:
    </p>

    <code>
      int main()
      {
        example_struct OneStructToRuleThemAll = { -42, 69, 42.0f };
        DebugPrint(&OneStructToRuleThemAll);
      }
    </code>

    <p>
      Produces the output:
    </p>

    <code>
      example_struct {
      example_struct::SomeNumber = -42
      example_struct::SomeOtherNumber = 69
      example_struct::FloatValue = 42.00000000000
      }
    </code>

    <h3>Closing Remarks</h3>
    <p>
      That is a brief overview of the very basics of metaprogramming with poof.
      In this nearly-trivial example program, we accomplished something that
      requires an almost comical 14192 lines of dependency code 
      (<a href="https://github.com/boostorg/pfr/tree/develop/include/boost">boost::pfr</a>)
       in C++.
    </p>

    <p>
      There are a number of real example programs you can run on your own machine
      and experiment with in the <a href="https://github.com/scallyw4g/poof/tree/master/examples">Github Repo</a>.
    </p>

    <p>
      For examples of real world code generated with poof, take a look at the
      standard library of poof functions included in <a href="https://github.com/scallyw4g/bonsai_stdlib/blob/master/src/poof_functions.h">Bonsai</a>.
      This library includes generics for containers, operator overloads, debug
      printing, and a number of other utility functions.
    </p>

  </div>

</body>

