<body>
  <div>
    <h5>Sept 4, 2025</h5>
    <h1>A Metaprogrammable GUI toolkit</h1>

    <div class=part-link-container>

      <div class=part-link>
        <a href='/vim/blog/gui-i'>
          <h4 class='part-link-0'>
            Part I
          </h4>
          <h4 class='part-link-1'>
            Displaying Engine Data
          </h4>
        </a>
      </div>


      <div class=part-link>
        <a href='/vim/blog/gui-ii'>
          <h4 class='part-link-0 active'>
            Part II
          </h4>
          <h4 class='part-link-1 active'>
            A Primitive Widget
          </h4>
        </a>
      </div>

      <div class=part-link>
        <a href='/vim/blog/gui-iii'>
          <h4 class='part-link-0'>
            Part III
          </h4>
          <h4 class='part-link-1'>
            Custom Widgets
          </h4>
        </a>
      </div>

      <div class=part-link>
        <a href='/vim/blog/gui-iv'>
          <h4 class='part-link-0'>
            Part IV
          </h4>
          <h4 class='part-link-1'>
            Low Level API
          </h4>
        </a>
      </div>


      </div>

    </div>
  </div>

  <div>
    <h3>Overview</h3>
    <p>
      So far, we've seen how to generate high-level DisplayUi functions for
      arbitrary datatypes.  Let's go a little deeper and understand how we'd
      implement the UI functions for the leaves of the type-tree.
    </p>

    <p>
      Let's define a type that represents a 3D vector quantity.
    </p>

    <code>
    struct v3 { f32 Elements[3]; }
    </code>

    <p>
      And take a look at the current default widget for this type in Bonsai.
    </p>


    <figure class='inline-block'>
      <img class='full-width' src="/assets/gui-ii-0.png"></img>
      <figcaption>The default widget</figcaption>
    </figure>

    <h3>Bonsai UI API</h3>
    <p>
      Before trying to construct the UI functions for this type, let's take a look
      at some of the API Bonsai provides that we're going to use.
    </p>

    <code>
      struct cs { u32 Count; char *Start; } // cs is a mnemonic for counted_string


      ui_element_reference PushTableStart(renderer_2d *Ui, ui_render_params *Params);
                      void PushTableEnd  (renderer_2d *Ui);

      void PushColumn(renderer_2d *Ui, cs Text);

      b32 Button(renderer_2d *Ui, cs Text, ui_id Id);
    </code>

    <p>
      Most elements will be contained within Tables, which are book-ended with
      PushTable(Start|End).  Tables are just layout containers, and do not
      necessarily contain tabular data. After opening a Table with PushTableStart,
      PushColumn will do most of the heavy lifting.
    </p>

    <p>
      With the API surface inspected, let's get to work
    </p>

    <code>
      // We'll hand-wave the lowest-level function for a minute ..
      //
      void UiDisplay(renderer_2d *Ui, f32 *Value);

      // Let's start by defining the function that displays a label and editor
      // widgets for the f32 elements
      //
      void UiDisplay(renderer_2d *Ui, cs Label, v3 *Vector)
      {
        PushTableStart(Ui);
          PushColumn(Ui, Label);

          UiDisplay(Ui, Vector->Elements + 0);
          UiDisplay(Ui, Vector->Elements + 1);
          UiDisplay(Ui, Vector->Elements + 2);

          PushNewRow(Ui);
        PushTableEnd(Ui);
      }

      // Now for the lowest level widget for displaying and editing an f32 value
      //
      void UiDisplay(renderer_2d *Ui, f32 *Value)
      {
        // These IDs have to be globally unique 128bit identifiers.
        // This computation is a stand-in for brevity
        ui_id Id0 = {"-" ^ Value};
        ui_id Id1 = {"+" ^ Value};

        PushTableStart(Ui);
          if (Button(Ui, CSz("-"), Id0)) { *Value -= 1.f; }
          PushColumn(Ui, CS(*Value);
          if (Button(Ui, CSz("+")), Id1) { *Value += 1.f; }
        PushTableEnd(Ui);
      }
    </code>

    <h3>Conclusion</h3>
    <p>
      Let's check out how we'd extend this to support different widget types
      for the same underlying datatype in <a href='/vim/blog/gui-iii'>Part III : Custom Widgets</a>
    </p>

  </div>

</body>

