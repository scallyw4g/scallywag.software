<body>
  <div>
    <h5>Sept 4, 2025</h5>
    <h1>A Metaprogrammable GUI toolkit</h1>

    <div class=part-link-container>

      <div class=part-link>
        <a href='/vim/blog/gui-i'>
          <h4 class='part-link-0'>
            Part I
          </h4>
          <h4 class='part-link-1'>
            Displaying Engine Data
          </h4>
        </a>
      </div>


      <div class=part-link>
        <a href='/vim/blog/gui-ii'>
          <h4 class='part-link-0 active'>
            Part II
          </h4>
          <h4 class='part-link-1 active'>
            A Primitive Widget
          </h4>
        </a>
      </div>

      <div class=part-link>
        <a href='/vim/blog/gui-iii'>
          <h4 class='part-link-0'>
            Part III
          </h4>
          <h4 class='part-link-1'>
            Custom Widgets
          </h4>
        </a>
      </div>

      <div class=part-link>
        <a href='/vim/blog/gui-iv'>
          <h4 class='part-link-0'>
            Part IV
          </h4>
          <h4 class='part-link-1'>
            Low Level API
          </h4>
        </a>
      </div>


      </div>

    </div>
  </div>

  <div>
    <h3>Overview</h3>
    <p>
      So far, we've seen how to generate high-level DisplayUi functions for
      arbitrary datatypes.  Let's go a little deeper and understand how we'd
      implement the UI functions for the leaves of the type-tree.
    </p>

    <p>
      Let's define a type that represents a 3D vector quantity.
    </p>

    <code>
    struct v3 { f32 Elements[3]; }
    </code>

    <p>
      And take a look at the current default widget for this type in Bonsai.
    </p>


    <figure class='inline-block'>
      <img class='full-width' src="/assets/gui-ii-0.png"></img>
      <figcaption>The default widget</figcaption>
    </figure>

    <h3>Bonsai UI API</h3>
    <p>
      Before trying to construct the UI functions for this type, let's take a look
      at some of the API Bonsai provides that we're going to use.
    </p>

    <code>
      ui_element_reference PushTableStart(renderer_2d *Ui);
                      void PushTableEnd  (renderer_2d *Ui);

      void PushColumn(renderer_2d *Ui, string Text);

      b32 Button(renderer_2d *Ui, string Text, ui_id Id);
    </code>

    <p>
      Most elements will be contained within Tables, which are book-ended with
      PushTable(Start|End).  Tables are layout containers; they do not
      necessarily contain tabular data. After opening a Table with
      PushTableStart, PushColumn will do most of the heavy lifting.
    </p>

    <p>
      The Button API is the first interactive element we've seen.  It requires
      that you construct a 'ui_id', which must be a globally unique identifier
      that represents the specific UI interaction.  Discussing robust construction
      of these IDs is outside the scope of this article, but could be the topic
      of future writing.
    </p>

    <p>
      Alright, with the API surface inspected, let's get to work.
    </p>

    <code>
      // Let's start by defining the v3 editor widget, which displays a label and
      // editor widgets for the three f32 values
      //
      void UiDisplay(renderer_2d *Ui, string Label, v3 *Vector)
      {
        PushTableStart(Ui);
          PushColumn(Ui, Label);

          UiDisplay(Ui, Vector->Elements + 0);
          UiDisplay(Ui, Vector->Elements + 1);
          UiDisplay(Ui, Vector->Elements + 2);

          PushNewRow(Ui);
        PushTableEnd(Ui);
      }

      // Now for the lowest level f32 widget
      //
      void UiDisplay(renderer_2d *Ui, f32 *Value)
      {
        // This computation is a stand-in for brevity
        ui_id Id0 = {"-" ^ Value};
        ui_id Id1 = {"+" ^ Value};

        PushTableStart(Ui);
          if (Button(Ui, String("-"), Id0)) { *Value -= 1.f; }
          PushColumn(Ui, String(*Value);
          if (Button(Ui, String("+")), Id1) { *Value += 1.f; }
        PushTableEnd(Ui);
      }
    </code>

    <h3>Conclusion</h3>
    <p>
      Great, we've seen how we can leverage poof to generate generic debug UI,
      and how we can manually implement the UI functions at the leaves of the type-tree.
    </p>

    <p>
      Let's check out how we'd extend this to support different widget types
      for the same underlying v3 datatype in <a href='/vim/blog/gui-iii'>Part III : Custom Widgets</a>
    </p>

  </div>

</body>

