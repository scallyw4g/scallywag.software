<body>
  <div>
    <h5>May 27, 2025</h5>
    <h1>A Metaprogrammable GUI toolkit</h1>

    <div class=part-link-container>

      <div class=part-link>
        <a href='/vim/blog/gui-i'>
          <h4 class='part-link-0 active'>
            Part I
          </h4>
          <h4 class='part-link-1 active'>
            Displaying Engine Data
          </h4>
        </a>
      </div>


      <div class=part-link>
        <a href='/vim/blog/gui-ii'>
          <h4 class='part-link-0'>
            Part II
          </h4>
          <h4 class='part-link-1'>
            A Primitive Widget
          </h4>
        </a>
      </div>

      <div class=part-link>
        <a href='/vim/blog/gui-iii'>
          <h4 class='part-link-0'>
            Part III
          </h4>
          <h4 class='part-link-1'>
            Custom Widgets
          </h4>
        </a>
      </div>

      <div class=part-link>
        <a href='/vim/blog/gui-iv'>
          <h4 class='part-link-0'>
            Part IV
          </h4>
          <h4 class='part-link-1'>
            Low Level API
          </h4>
        </a>
      </div>

    </div>
  </div>

  <div>
    <h3>Preamble</h3>
    <p>
      The following article series makes use of a metaprogramming tool I wrote called `poof`.
        For those unfamiliar with the tool, I would recommend at least skimming the <a href='/vim/blog/poof-i'>Introduction to Poof</a>.
    </p>

    <h3>Problem Statement</h3>
    <p>
      For my game engine project, Bonsai, I wanted to build a GUI toolkit that satisfied a few requirements:

      <ul>
        <li>
          1. Extremely low programmer overhead for the boring but important job
          of displaying arbitrary engine data at runtime.
        </li>

        <li>2. Low overhead for building custom UI widgets.</li>

        <li>3. Ability to build sophisticated and pixel perfect UI components
               with arbitrarily complex interaction responses.</li>
      </ul>
    </p>

    <p>
      
    </p>

    <p>First of all, what do I mean by "engine data"?</p>

    <figure class='inline-block'>
      <img class='full-width' src="/assets/engine_data.png"></img>
      <figcaption>Some of the engine data Bonsai displays</figcaption>
    </figure>

    <p>
      This is an example of UI displaying a small portion of the
      `engine_resources` struct.  engine_resources is a global singleton which
      contains, or points to, every piece of data that the engine uses at
      runtime.
    </p>

    <p>
      The above UI is completely generated at compile time by a metaprogramming
      tool called `poof`.  The basic observation is that every data structure
      forms a type-tree of sorts, with the leaves being primitive types..  u32,
      s32, float, string, etc.  For generating UI, we would really like to
      iterate over the members of a given type and recurse down the type-tree
      for each member, doing a UI display function at each level.
    </p>

    <p>
      Unlike in C++, iterating over the members in a type is easy with poof.
      Inside a poof function, we simply call `type.map`, and the runtime
      executes the following block for each member.
    </p>

    <p>
      In the context of generating UI for our datastructures, we can (ab)use
      C++ function polymorphism and call a display function for each member.
      In this example, we'll call the C++ display function UiDisplay.  This
      example follows the same pattern outlined in the <a href='/vim/blog/poof-i'>Introduction to Poof</a>
      mentioned at the start of this article.  Now would be a good time to skim
      that if you're unfamiliar with the basics of how poof works.
    </p>

    <code>

    // The poof function that generates the C++ UiDisplay function
    //
    poof(

      func gen_ui_display(type)
      {
        void UiDisplay(renderer_2d *Ui, type *Element)
        {
          type.map(member) // iterate over members of 'type'
          {
            // emit a display function call for each member in 'type'
            UiDisplay(Ui, &Element->(member.name));
          }
        }
      }

    )
    </code>

    <h4>
      And the code that calls it
    </h4>
    <code>
      // Consider an example entity struct
      //
      struct entity
      {
        u32 EntityIndex;
        mesh_3d Mesh;
        transform_3d Transform;
      };

      // We can call the meta func that generates UiDisplay for an 'entity' like so
      //
      poof(gen_ui_display(entity))
      #include "generated/gen_ui_display_entity.h"


      // Which produces the following inside "generated/gen_ui_display_entity.h"
      //
      void UiDisplay(renderer_2d *Ui, entity *Element)
      {
        UiDisplay(Ui, &Element->EntityIndex);
        UiDisplay(Ui, &Element->Mesh); 
        UiDisplay(Ui, &Element->Transform);
      }

      // We make the assumption in this example that we've already called the
      // gen_ui_display poof function for mesh_3d and transform_3d types.
      // Worth noting, there exists an easy way to automate this process, but
      // for brevity I've omitted it in this example.

    </code>

    <p>
      This is the basic premise that the UI toolkit in Bonsai uses to display
      arbitrary engine data at runtime.  The actual implementation is somewhat
      more sophisticated than the example above, but the general idea is the
      same.  For every member of a type, call `UiDisplay` .. which in turn is
      composed of more display functions ..  until you get to the primitive
      'leaves' of the type tree.
    </p>

    <p>
      The UI it generates is all very generic and boring, but that's the point;
      it's very fast for a programmer to get runtime data on the screen.
    </p>

    <p>
      Let's take a closer look in <a href='/vim/blog/gui-ii'>Part II : A Primitive Widget</a>
    </p>

  </div>
</body>

